console.log('LinkedIn AI Commenter: Background script loaded');

// Keep service worker alive
chrome.runtime.onStartup.addListener(() => {
  console.log('Background: Extension started');
});

chrome.runtime.onInstalled.addListener(() => {
  console.log('Background: Extension installed/updated');
});

// Handle messages from content script
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  console.log('Background: Received message', request);
  
  if (request.type === 'getComment') {
    console.log('Background: Processing comment request for post:', request.postContent?.substring(0, 100) + '...');
    
    // Get API key from storage
    chrome.storage.local.get('apiKey', async (data) => {
      if (!data.apiKey) {
        console.error('No API key found');
        sendResponse({ 
          error: 'No API key configured. Please add your Gemini API key in the extension popup.' 
        });
        return;
      }
      
      try {
        const comment = await generateComment(data.apiKey, request.postContent);
        console.log('Background: Generated comment:', comment);
        sendResponse({ comment });
      } catch (error) {
        console.error('Error generating comment:', error);
        sendResponse({ 
          error: 'Failed to generate comment. Please check your API key and try again.' 
        });
      }
    });
    
    return true; // Keep the message channel open for async response
  }
  
  return false; // Don't keep channel open for other message types
});

// Function to generate comment using Gemini API
async function generateComment(apiKey, postContent) {
  const prompt = `You are a professional LinkedIn user who writes thoughtful, engaging comments on posts. 

Post content: "${postContent}"

Generate a professional, relevant comment that:
- Shows genuine engagement with the content
- Adds value to the conversation
- Is 2-3 sentences maximum
- Uses a friendly but professional tone
- Avoids generic phrases like "Great post!" or "Thanks for sharing!"
- Is personalized to the specific content
- May include a relevant question or insight
- Uses appropriate emojis sparingly (0-1 emoji max)

Comment:`;

  const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      contents: [{
        parts: [{
          text: prompt
        }]
      }],
      generationConfig: {
        temperature: 0.7,
        topK: 40,
        topP: 0.95,
        maxOutputTokens: 150,
      },
      safetySettings: [
        {
          category: "HARM_CATEGORY_HARASSMENT",
          threshold: "BLOCK_MEDIUM_AND_ABOVE"
        },
        {
          category: "HARM_CATEGORY_HATE_SPEECH",
          threshold: "BLOCK_MEDIUM_AND_ABOVE"
        },
        {
          category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
          threshold: "BLOCK_MEDIUM_AND_ABOVE"
        },
        {
          category: "HARM_CATEGORY_DANGEROUS_CONTENT",
          threshold: "BLOCK_MEDIUM_AND_ABOVE"
        }
      ]
    })
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(`Gemini API error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);
  }

  const data = await response.json();
  
  if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
    throw new Error('No content generated by Gemini API');
  }
  
  const generatedText = data.candidates[0].content.parts[0].text.trim();
  
  // Clean up the response (remove any "Comment:" prefix if present)
  return generatedText.replace(/^Comment:\s*/i, '').trim();
}

// Keep service worker alive by periodically performing a small task
let keepAliveInterval;

function keepServiceWorkerAlive() {
  keepAliveInterval = setInterval(() => {
    chrome.storage.local.get('keepAlive', () => {
      // This small operation helps keep the service worker active
      if (chrome.runtime.lastError) {
        console.log('Keep alive check:', chrome.runtime.lastError);
      }
    });
  }, 20000); // Every 20 seconds
}

// Start keep alive when extension loads
keepServiceWorkerAlive();

// Clean up on shutdown
chrome.runtime.onSuspend.addListener(() => {
  console.log('Background: Service worker suspending');
  if (keepAliveInterval) {
    clearInterval(keepAliveInterval);
  }
});
